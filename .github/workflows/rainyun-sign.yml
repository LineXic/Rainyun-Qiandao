name: Rainyun 自动签到

on:
  schedule:
    - cron: '0 4 * * *'  # UTC+8 12点执行
    - cron: '0 0 1 * *'  # 每月1日0点执行保活机制
  workflow_dispatch:
    # 允许手动触发，并支持传递重试参数
    inputs:
      is_retry:
        description: '是否为重试执行'
        required: false
        default: 'false'
        type: boolean
      retry_count:
        description: '重试次数'
        required: false
        default: '0'
        type: number
  # 允许workflow_dispatch事件触发，用于重试

permissions:
  # 增加必要的权限以允许触发工作流
  actions: write
  contents: read

jobs:
  sign-in:
    runs-on: ubuntu-latest
    # 添加重试策略，最多3次重试（根据需要调整）
    # 但我们会使用自定义重试逻辑以满足时间限制要求
    steps:
      - uses: actions/checkout@v3
      
      - name: 设置Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: 缓存Python依赖
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-
      
      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      # 移除Chrome浏览器缓存，因为缓存系统目录可能导致权限问题
      # 使用webdriver-manager自动管理ChromeDriver，无需缓存
      
      - name: 安装Chrome和ChromeDriver
        run: |
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable curl unzip
          # 使用webdriver-manager自动管理ChromeDriver版本
          pip install webdriver-manager chromedriver-binary-auto
      
      - name: 确保temp目录存在
        run: mkdir -p temp
      
      - name: 网络诊断与优化
        run: |
          echo "=== 详细网络诊断 ==="
          # 测试多个域名和IP
          echo "测试雨云主站..."
          curl -s -o /dev/null -w "雨云主站: %{http_code}" https://app.rainyun.com
          echo "\n测试雨云备用站..."
          curl -s -o /dev/null -w "雨云备用站: %{http_code}" https://www.rainyun.com
          
          # 测试DNS解析
          echo "\n=== DNS解析测试 ==="
          nslookup app.rainyun.com || true
          nslookup www.rainyun.com || true
          
          # 检查网络延迟
          echo "\n=== 网络延迟测试 ==="
          ping -c 3 app.rainyun.com || true
          echo "\n=== 路由追踪 ==="
          traceroute app.rainyun.com || true
          
          # 增加系统资源信息
          echo "\n=== 系统资源信息 ==="
          free -h
          df -h
          lsb_release -a || cat /etc/os-release
          
          # 优化系统网络参数
          echo "\n=== 优化网络参数 ==="
          sudo sysctl -w net.ipv4.tcp_keepalive_time=60
          sudo sysctl -w net.ipv4.tcp_keepalive_intvl=15
          sudo sysctl -w net.ipv4.tcp_keepalive_probes=5
          sudo sysctl -p
      
      - name: 执行签到脚本（优先使用API模式）
      id: sign_in
      # 添加超时时间为30分钟
      timeout-minutes: 30
      run: |
        # 首先运行网络诊断
        echo "=== 执行签到前网络诊断 ==="
        ping -c 4 app.rainyun.com || true
        ping -c 4 www.rainyun.com || true
        
        # 显示DNS解析结果
        echo "\n=== DNS解析结果 ==="
        nslookup app.rainyun.com || true
        nslookup www.rainyun.com || true
        
        # 设置环境变量控制API优先模式（强制开启API优先）
        export CONNECTION_TIMEOUT="60"
        export NODE_TLS_REJECT_UNAUTHORIZED="0"
        
        # 增加重试循环
        max_attempts=3
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "\n===== 执行签到尝试 $attempt/$max_attempts ====="
          
          # 执行签到脚本
          python rainyun.py
          
          # 检查退出码
          if [ $? -eq 0 ]; then
            echo "签到成功！"
            exit 0
          fi
          
          attempt=$((attempt + 1))
          
          if [ $attempt -le $max_attempts ]; then
            wait_time=$((attempt * 2 * 60))  # 递增等待时间：2分钟、4分钟、6分钟
            echo "\n签到失败，$wait_time秒后进行第$attempt次尝试..."
            sleep $wait_time
          fi
        done
        
        echo "\n所有尝试都失败了，请检查网络连接或手动运行工作流！"
        exit 1
      env:
        # 请在GitHub仓库的Settings > Secrets and variables > Actions中设置这些密钥
        RAINYUN_USER: ${{ secrets.RAINYUN_USER }}
        RAINYUN_PASS: ${{ secrets.RAINYUN_PASS }}
        # 设置无头模式环境变量
        HEADLESS: "true"
        # 启用调试日志
        DEBUG: "true"
        # 确保使用系统路径中的ChromeDriver
        CHROMEDRIVER_PATH: "chromedriver"
        # 增加网络超时设置
        CONNECTION_TIMEOUT: "60"
        # 禁用TLS验证（在某些环境中可能需要）
        NODE_TLS_REJECT_UNAUTHORIZED: "0"
      
      - name: 清理临时文件
        run: rm -rf temp
        if: always()  # 即使前面步骤失败也执行清理
      
      # 失败重试机制 - 优化版
      - name: 检查执行状态并安排重试
        if: failure() && github.event_name != 'schedule' || (failure() && github.event_name == 'schedule' && github.event.schedule != '0 0 1 * *')
        run: |
          echo "签到失败，尝试安排重试..."
          
          # 获取当前时间并计算重试时间（1小时后，UTC+8 22点前）
          CURRENT_TIME=$(date -u +"%H")
          TARGET_HOUR="14"  # UTC+8 22点对应UTC 14点
          
          # 检查是否在可重试时间范围内
          if [ "$CURRENT_TIME" -lt "$TARGET_HOUR" ]; then
            # 读取重试次数
            RETRY_COUNT=${{ github.event.inputs.retry_count || 0 }}
            
            # 限制最大重试次数为3次
            if [ "$RETRY_COUNT" -lt 3 ]; then
              NEXT_RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "将在1小时后进行第$NEXT_RETRY_COUNT次重试..."
              
              # 使用GitHub API触发工作流
              RESPONSE=$(curl -s -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                https://api.github.com/repos/${{ github.repository }}/dispatches \
                -d "{\"event_type\":\"retry-signin\",\"client_payload\":{\"is_retry\":true,\"retry_count\":$NEXT_RETRY_COUNT}}"
              )
              
              # 检查API调用是否成功（由于GitHub API的性质，即使成功也不会返回内容）
              CURL_STATUS=$?
              if [ $CURL_STATUS -eq 0 ]; then
                echo "成功安排重试！"
                exit 0
              else
                echo "API调用失败，错误代码: $CURL_STATUS"
                echo "响应: $RESPONSE"
                echo "建议手动触发签到。"
                exit 1
              fi
            else
              echo "已达到最大重试次数3次，不再自动重试。"
              echo "请手动检查并触发签到。"
            fi
          else
            echo "当前时间已过UTC+8 22点，今天不再安排重试。"
            echo "请在明天再尝试。"
          end
        uses: actions/github-script@v6
        with:
          # 使用特殊权限的token
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 获取重试相关参数
            const isRetry = ${{ github.event.inputs.is_retry || 'false' }};
            let retryCount = parseInt(${{ github.event.inputs.retry_count || '0' }});
            
            // 获取当前时间并转换为UTC+8时区
            const now = new Date();
            const utc8Time = new Date(now.getTime() + 8 * 60 * 60 * 1000);
            const currentHour = utc8Time.getHours();
            
            console.log(`当前UTC+8时间: ${utc8Time.toISOString()}`);
            console.log(`当前UTC+8小时: ${currentHour}`);
            console.log(`是否重试: ${isRetry}, 当前重试次数: ${retryCount}`);
            
            // 限制最大重试次数为3次，避免无限重试
            const MAX_RETRIES = 3;
            
            // 检查是否在UTC+8晚上10点前且重试次数未超过限制
            if (currentHour < 22 && retryCount < MAX_RETRIES) {
              retryCount++;
              console.log(`准备进行第${retryCount}次重试，最大重试次数: ${MAX_RETRIES}`);
              
              try {
                // 使用workflow_run替代workflow_dispatch以避免权限问题
                // 或者使用更可靠的重试策略
                console.log(`将通过actions/github-script触发工作流重试`);
                
                // 尝试使用REST API触发重试
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'rainyun-sign.yml',
                  ref: context.ref,
                  inputs: {
                    is_retry: 'true',
                    retry_count: retryCount.toString()
                  }
                });
                
                console.log(`重试已成功安排，将在工作流队列中执行第${retryCount}次尝试`);
              } catch (error) {
                console.error('API触发重试失败:', error.message);
                
                // 如果API调用失败，采用替代方案
                console.log('尝试使用替代方案进行重试...');
                
                // 直接输出重试指令，让用户知道需要手动重试
                console.log('\n=== 重要通知 ===');
                console.log(`工作流执行失败，建议手动触发重试。错误信息: ${error.message}`);
                console.log(`当前已尝试次数: ${retryCount}/3`);
                console.log('=== 重要通知 ===');
              }
            } else if (retryCount >= MAX_RETRIES) {
              console.log(`已达到最大重试次数${MAX_RETRIES}次，停止重试`);
              console.error('工作流执行失败，已超过最大重试次数');
            } else {
              console.log('当前时间已过UTC+8晚上10点，停止重试');
              console.error('工作流执行失败，且已超过重试时间限制');
            }

      # 保活机制 - 优化版
      - name: Keepalive Workflow
        if: github.event.schedule == '0 0 1 * *'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 自动更新工作流文件以保持活跃状态
            try {
              console.log('开始执行工作流保活操作...');
              
              const workflow = await github.rest.actions.getWorkflow({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'rainyun-sign.yml'
              });
              
              // 尝试触发工作流作为保活
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'rainyun-sign.yml',
                ref: context.ref,
                inputs: {
                  is_retry: 'false',
                  retry_count: '0'
                }
              });
              
              console.log('工作流保活成功！');
            } catch (error) {
              console.error('工作流保活失败:', error.message);
              // 提供备选方案建议
              console.log('备选方案: 请考虑创建专用的Personal Access Token并添加为仓库密钥');
            }